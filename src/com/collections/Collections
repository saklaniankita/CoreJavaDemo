https://www.javatpoint.com/collecti ons-in-java

If Insertion order has to be maintained then we should go for some List Implementation
1) In case it is a single threaded environment, we should go for either ArrayList or Linked List which is non synchronized
and synchronization in case of single threaded environment will make it uselessly slow 
2) But for a multithreaded environment, we should go for Vector which is synchronized.
3) Insertion in case of LinkedList is easier because we need to modify just two pointers to insert an element
  But in case of ArrayList , the whole list needs to be shifted to insert just one element.
4) Duplicates are allowed in all implementations of List interface.
5) The stack is the subclass of Vector. It implements the last-in-first-out LIFO data structure, i.e., Stack. 
It has only 5 methods like push, pull, peek, empty, search
-> if we want to get the first element from a stack (of say 100 elements), then we will have to perform 100 
   pop operations, So better to use Stack when we have fewer number of elemnts to be stored. 
   When elements are higher in number then better go for either arraylist or LinkedList that has get(int i) method
   to retreive element from any index of list in one go.
-> Collections.synchronizedList(), 

==> Arraylist
   --> ArrayList in Java is a Resizable-array implementation of the List interface.
   --> Any  number of NULL values allowed
   --> An ordered collection
   --> Internally ArrayList class uses an Array of Object class to store its elements.
   --> When initializing an ArrayList you can provide initial capacity, But still the size would be zero because
      there are no elements yet in the list.
   --> If initial capacity is not specified then default capacity is used to create an array. Default capacity is 10.
   --> When an element is added to an ArrayList it first verifies whether it can accommodate the new element or 
       it needs to grow, in case capacity has to be increased then the new capacity is calculated which is 
       50% more than the old capacity and a new array is created with this new capacity.
   --> Please note there is a difference between size and capacity. list.size() returns the number of elements in the list
       whereas there is no direct method to retrieve the capapcity.
   --> When elements are removed from an ArrayList space created by the removal of an element has to be filled 
       in the underlying array. That is done by Shifting any subsequent elements to the left.
       
==> Array & ArrayList
  ->Array is FIXED size and we need to initialize the array with its capacity
    ArrayList is DYNAMIC i.e capacity may change as and when required and we dont need to initialize it(though we CAN)
  ->Array stores primitive datatypes as well as Wrapper classes
    ArrayList stores only Wrapper class. even if we add primitive datatype, it will internally autobox.
    
===> SET
-> If you do not want duplicates, go for Set
-> It allows single null value
-> They are unordered
-> HashSet uses hashing internally
-> HashSet stores values in a hashMap internally with its keys as hashSet elements and values as a constant
   called PRESENT i.e when we create a HashSet as HashSet<String> hs = new HashSet<String>(); then inside HashSet 
   constructor we have the following code:
                        HashSet(){
                        map = new HashMap<String, Object>();             
                        }
                        public Boolean add(Object o){
                        	return map.put(o, PRESENT);
                        }
   Since keys are unique in a HashMap, it provides uniqueness guarantee of Set interface.
   & HashSet's add(Object a) method internally calls HashMap's put(Object a, PRESENT)
  -> HashSet also implements Searlizable and Cloneable interfaces
  -> HashSet is not synchronized, we use Collections.synchronizedSet(set) to make it synchronized
  -> The iterators returned by this class’s iterator method are **fail-fast and may throw 
      ConcurrentModificationException if the set is modified at any time after the iterator is 
      created, in any way except through the iterator’s own remove() method.


===> QUEUE
->  Queue interface maintains the first-in-first-out order.
   * It can be defined as an ordered list as it maintains insertion order, FIFO
   * Queue doesn’t permit NULL values.
   * The head of the queue is the least element with respect to the specified ordering.
   * If multiple elements are tied for least value, the head is one of those elements — ties are broken arbitrarily.
   * The queue retrieval operations poll, remove, peek, and element access the element at the head of the queue.
   * with queues, operations on the head are fastest (e.g. offer() and remove()), 
     whereas operations on middle elements are slow (e.g. contains(e) and remove(e)).
   * LinkedList & ArrayDeque implements Dequeue (LinkedList implements both queue and List)
     ==> LINKED LIST
     * Implements Dequeue interface
     * NOT thread safe
     * Consider using a LinkedList when you want fast adding and fast removing elements
       at both ends, plus accessing elements by index.
     
     ==> ARRAY DEQUEUE
     * implements Dequeue interface
     * NOT thread safe
     * Double ended queue
     
     ==> PRIORITY QUEUE
      * Directly implements Queue interface
      * NOT thread safe
      * We can’t create PriorityQueue of Objects that are non-comparable
      * PriorityQueue keeps the lowest element as per Comparator or Comparable at head position
      * PriorityQueue are unbound queues.
      * Fast retrieval from head and fast addition to tail.
    
    ==> BLOCKING QUEUE interface (extends Queue interface): 
    *Its implementations are THREAD SAFE
    *Java 5 comes with BlockingQueue implementations in the java.util.concurrent package.
    *Its implementations include LinkedBlockingQueue, ArrayBlockingQueue, PriorityBlockingQueue, SynchronousQueue
    *BlockingQueue interface supports flow control (in addition to queue) by introducing blocking 
      if either BlockingQueue is full or empty
    *A thread trying to enqueue an element in a full queue is blocked until some other thread makes 
      space in the queue, either by dequeuing one or more element or clearing the queue completely.
    *Similarly it blocks a thread trying to delete from an empty queue until some other threads inserts an item. 
    *BlockingQueue does not accept null value. If we try to enqueue null item, then it throws NullPointerException.
         Unbound BlockingQueue : BlockingQueue blockingQueue = new LinkedBlockingDeque(); 
         Bound BlockingQueue : BlockingQueue blockingQueue = new LinkedBlockingDeque(5);
   
   
===> LinkedList: this class implements both List and Deque interface, thus having hybrid characteristics and 
     behaviors of list and queue. 
     
===> MAP

===> Enumeration vs Iterator
    -> Iterator can be fail-fast or fail-safe in nature whereas Enumeration is always fail-safe i.e 
       it  never throws exception even if the underlying collection is modified while iterating
    -> Iterator allows to remove the current elemnet (itr.remove() mehtod) whereeasEnumeration can't do that
    -> Iterator methods are hasNext() & next() and Enumeration methods are hasMoreElements() and nextElement()
    -> So, Iterator is always peferred over Enumertaion
